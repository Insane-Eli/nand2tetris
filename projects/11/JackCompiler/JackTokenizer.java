
import java.io.*;

/* 

Effects the actual compilation output.

Gets its input from a JackTokenizer and emits its parsed structure into an output file/stream.
The output is generated by a series of compilexxx ( ) routines, one for every syntactic 
element xxx of the Jack grammar. The contract between these routines is that each compilexxx ( ) 
routine should read the syntactic construct xxx from the input, advance ( ) the
tokenizer exactly beyond xxx, and output the parsing of xxx.
Thus, compilexxx ( ) may only be called if indeed xxx is the next syntactic element of the input.

In the first version of the compiler, described in chapter 10, this module emits a structured printout of
the code, wrapped in XML tags. In the final version of the compiler, described in chapter 11, this module
generates executable VM code. In both cases, the parsing logic and module API are exactly the same.

 */

public class JackTokenizer {

    public void debug() {
        System.out.println("\ttoken: " + currentToken + ", type: " + currentType);
    }

    private String input;
    private int cursor;
    private String currentLine;

    /* Declare state variables for storing the tokenType, currentIdentifier, currentInteger
		currentString and currentKeyword
     */
    private String currentToken = "";
    private Type currentType;

    public enum Type {
        KEYWORD, SYMBOL, IDENTIFIER, INT_CONSTANT, STRING_CONSTANT
    }


    /* Create lookups for the different types (valid keywords, integer characters, starting
	identifier characters, identifier characters and symbols) */
    private static final String[] keywords = {
        "class", "constructor", "function", "method", "field",
        "static", "var", "int", "char", "boolean",
        "void", "true", "false", "null", "this",
        "let", "do", "if", "else", "while", "return"
    };

    private static final Character[] symbols = {
        '{', '}', '(', ')', '[',
        ']', '.', ',', ';', '+',
        '-', '*', '/', '&', '|',
        '<', '>', '=', '~'
    };

    private static final String validIntChars = "0123456789";

    // first character of an identifier must be a letter or underscore
    private static final String validIdentifierStartChars = "_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    // after the first char, everything else is viable
    private static final String validIdentifierChars = validIntChars + validIdentifierStartChars;

    /**
     * The constructor will open the inputFile and read all of the lines into an
     * array for processing. The file can then be closed. *
     */
    public JackTokenizer(FileReader inputFile) {

        System.out.println("DONE!");

        input = "";
        cursor = 0;

        try {

            try (BufferedReader br = new BufferedReader(inputFile)) {
                currentLine = "";
                
                while ((currentLine = br.readLine()) != null) {
                    input += currentLine + "\n";
                    //System.out.println(currentLine);
                }
            }

            System.out.println("Tokenizing complete!");

        } catch (IOException e) {
            System.out.print("jack tokenizer constructor error: " + e);
        }
    }

    /**
     * hasMoreTokens will advance the cursor to a valid character. It will skip
     * over comments and multi-line comments until it finds a valid token
     * character or reaches the end of the file.  *
     */
    public boolean hasMoreTokens() {
        while (cursor < input.length()) {
            char c = input.charAt(cursor);

            // Skip blank lines (advance to the next line)
            if (Character.isWhitespace(c)) {
                cursor++;
                continue;
            }

            // Filter out single line comments from the current line of code starting from
            // the "//" comment start to the end of the line
            if (c == '/' && cursor + 1 < input.length() && input.charAt(cursor + 1) == '/') {
                cursor += 2;
                while (cursor < input.length() && input.charAt(cursor) != '\n') {
                    cursor++;
                }
                continue;
            }

            // Skip multi-line comments. Set ML-comment mode and keep advancing cursors until 
            // the "*/" delimiter is found.
            if (c == '/' && cursor + 1 < input.length() && input.charAt(cursor + 1) == '*') { // if "/*"
                cursor += 2;
                if (input.charAt(cursor) == '*') { // if "/**"
                    cursor++;
                }
                while (cursor + 1 < input.length() && !(input.charAt(cursor) == '*' && input.charAt(cursor + 1) == '/')) { // wait for "*/"
                    cursor++;
                }
                cursor += 2;
                continue;
            }

            return true;
        }

        // We know that we are either at the end of the file or the start of a valid token
        // is pointed to by the character cursor.
        return false;
    }

    /**
     * JackTokenizer initially has no current token. hasMoreTokens() will always
     * get called prior to advance() and advance() will only get called if
     * hasMoreTokens() returns true. We can assume that if advance is getting
     * called, the cursor must be positioned at the start of a valid token.
     * advance() looks at the current character to determine the type of token
     * and will build a string while incrementing the cursor location until an
     * invalid character is encountered.  *
     */
    public void advance() {
        if (!hasMoreTokens()) {
            return;
        }
        if (cursor >= input.length()) {
            return;
        }

        char c = input.charAt(cursor);

        // We know we are on a valid token starting character. Based on this character, we
        // will either call parseSymbol() or loop to gather all of the characters to build 
        // a string of the token. When we reach an invalid character for the token, we call 
        // parseInt, parseIdentifier or parseString method.
        // symbol
        for (char sym : symbols) {
            if (c == sym) {
                parseSymbol();
                return;
            }
        }
        // digit
        if (validIntChars.indexOf(c) != -1) {
            parseInt();
            return;
        }

        // string
        if (c == '"') {
            parseString();
            return;
        }

        // identifier
        if (validIdentifierStartChars.indexOf(c) != -1) {
            currentToken = parseIdentifier();
            return;
        }

        // default (should never happen)
        System.out.println("NO KEYWORD FOUND, DEFAULT CASE, ERROR ERROR ERROR, cursor: " + cursor);
        cursor++;
    }

    /**
     * parseInt() will form an integer value by collecting characters one at a
     * time (as long as the character is another digit). The resultant value is
     * stored in a variable to be used in the future as an integerConstant
     * lexical element. *
     */
    private void parseInt() {

        // Set the token type
        currentType = Type.INT_CONSTANT;

        String number = "";

        // Walk through each character. As long as we have an integer value, accumulate
        // the value into the current int state variable
        while (cursor < input.length() && validIntChars.indexOf(input.charAt(cursor)) != -1) {
            number += input.charAt(cursor);
            cursor++;
        }

        currentToken = number;
    }

    /**
     * parseIdentifier() will collect a sequence of letter, digits and
     * underscores ('_') not starting with a digit. The resultant value is as a
     * String. *
     */
    private String parseIdentifier() {

        String str = "";

        // Walk through each character. As long as we have a valid character, append it
        // to a string holder. 
        while (cursor < input.length() && validIdentifierChars.indexOf(input.charAt(cursor)) != -1) {
            str += input.charAt(cursor);
            cursor++;
        }

        // Compare the string to the valid keywords
        // If we have a keyword, set the token type and keyword
        for (String k : keywords) {
            if (k.equals(str)) {
                currentType = Type.KEYWORD;
                return str;
            }
        }
        // If we do not have a keyword, we have an identifier. Set the token type
        // and identifier state value.

        currentType = Type.IDENTIFIER;
        return str;
    }

    /**
     * parseString() will collect a sequence of Unicode characters not including
     * double quote or newline and store the value in a state variable for the
     * current stringConstant. *
     */
    private void parseString() {

        // Set the token type
        currentType = Type.STRING_CONSTANT;
        String str = "";

        // The first character is a quote. Skip past and append every character to a string
        // until the ending quote is encountered.
        cursor++;

        // Set the string state value to the collected string.
        while (cursor < input.length() && input.charAt(cursor) != '"') {
            str += input.charAt(cursor);
            cursor++;
        }

        currentToken = str;

        // Advance the character cursor past the closing quote.	
        if (cursor < input.length() && input.charAt(cursor) == '"') {
            cursor++;
        }
    }

    /**
     * parseSymbol() will collect a character to be stored in the symbol state
     * variable. *
     */
    private void parseSymbol() {

        // Set the token type
        currentType = Type.SYMBOL;

        // Set the current symbol state variable
        currentToken = String.valueOf(input.charAt(cursor));

        cursor++;
    }

    /**
     * The GETTER methods for the state variables. *
     */
    public Type tokenType() {
        return currentType;
    }

    public String token() {
        return currentToken;
    }

    public String keyWord() {
        if (currentType == Type.KEYWORD) {
            return currentToken;
        } else {
            System.out.println("ERROR: current token != keyword");
            debug();
            return "0";
        }
    }

    public char symbol() {
        if (currentType == Type.SYMBOL && currentToken.length() == 1) {
            return currentToken.charAt(0);
        } else {
            System.out.println("ERROR: current token != symbol OR isn't length 1");
            debug();
            return '0';
        }
    }

    public String identifier() {
        if (currentType == Type.IDENTIFIER) {
            return currentToken;
        } else {
            System.out.println("ERROR: current token != identifier");
            debug();
            return "0";
        }
    }

    public int intVal() {
        if (currentType == Type.INT_CONSTANT) {
            return Integer.parseInt(currentToken);
        } else {
            System.out.println("ERROR: current token != int constant");
            debug();
            return 0;
        }
    }

    public String stringVal() {
        if (currentType == Type.STRING_CONSTANT) {
            return currentToken;
        } else {
            System.out.println("ERROR: current token != string constant");
            debug();
            return "0";
        }
    }
}
